#!/bin/sh

VERSION='0.0.3+20151104'

printHelp() {
	printf %s "\
  VERSION: $VERSION

  USAGE: $(basename $0) [<options>] [--] <path>

  OPTIONS
  -d, --delete-backup - Delete backup refs in .git/refs/original
  -e, --expire        - Expire reflogger
  -f, --force         - Passed to git-filter-branch and git-rm
  -n, --dry-run       - Passed to git-rm
  -p, --prune         - Delete file objects
  -h, --help          - Display this help screen and exit
  -v, --version       - Display version info and exit
  --                  - end of options, path is next

  DESCRIPTION
  * WARNING: backup (clone) your repo first!
  * path = file: destructively remove all versions of the file,
    including renames and moves.
  * path = directory: do file deletion per above,
    for every version of every file that ever existed in the directory tree.
    (Versions of files that were in the directory,
    but were moved elsewhere, are not affected;
    only the versions that were in the directory tree are nuked.)
  * Paths must not contain newline characters.

  EXAMPLES
  $(basename $0) .ssh/id_rsa
  $(basename $0) Documents/

  SIMILAR/REFERENCES
  * https://git-scm.com/docs/git-filter-branch
  * http://dound.com/2009/04/git-forever-remove-files-or-folders-from-history/
  * https://stackoverflow.com/questions/8083282/how-do-i-remove-a-big-file-wrongly-committed-in-git
  * https://stackoverflow.com/questions/2100907/how-to-remove-delete-a-large-file-from-commit-history-in-git-repository
  * https://github.com/tj/git-extras/blob/master/Commands.md#git-obliterate
  "
}

logger() {
	MESSAGE="$(date +%T): $@"
	SUMMARY="$SUMMARY
$MESSAGE"
	printf '%s\n' "$MESSAGE"
}

delete_commits() {
	unset EXIT_CODE
	OLD_IFS="$IFS"
	IFS=$(printf '\n')
	for P in $($GIT_FILE_HISTORY --name-only -- "$FILE_PATH"); do
		logger "Nuking $FILE_PATH : $P"

		git filter-branch                                                              \
			--index-filter "git rm $FORCE $DRY_RUN --cached --ignore-unmatch -- '$P'" \
			--tag-name-filter cat                                                        \
			--prune-empty                                                                \
			$FORCE                                                                       \
	  	--                                                                           \
			--all
		if [ $? -ne 0 ]; then
			EXIT_CODE=$?
			break
		fi
	done
	[ "$EXIT_CODE" ] || EXIT_CODE=$?
	IFS="$OLD_IFS"

	return $EXIT_CODE
}

delete_backup() {
	logger "Nuking $FILE_PATH : deleting original refs"
	git for-each-ref --format="%(refname)" refs/original/ \
		| xargs -n 1 git update-ref -d
}

delete_reflogger() {
	logger "Nuking $FILE_PATH : deleting reflog"
	git reflog expire --expire=now --all
}

delete_objects() {
	logger "Nuking $FILE_PATH : deleting objects"
	git gc --prune=now
}

# Defaults
unset DRY_RUN
unset FORCE
unset REMOVE_ORIGINAL
unset EXPIRE
unset PRUNE
unset FILE_PATH

# get input options
while [ $# -gt 0 ]; do
	case "$1" in
		'-f'|'--force'          ) FORCE='--force'                           ;;
		'-n'|'--dry-run'        ) DRY_RUN='--dry-run'                       ;;
		'-r'|'--remove-original') {                    REMOVE_ORIGINAL=1; } ;;
		'-e'|'--expire'         ) {          EXPIRE=1; REMOVE_ORIGINAL=1; } ;;
		'-p'|'--prune'          ) { PRUNE=1; EXPIRE=1; REMOVE_ORIGINAL=1; } ;;
		'-h'|'--help'           ) { printHelp;         exit;              } ;;
		'-v'|'--version'        ) { echo "$VERSION";   exit;              } ;;
		'--'                    ) { FILE_PATH="$2";    break;             } ;;
		*                       ) FILE_PATH="$1"                            ;;
	esac
	shift
done

if [ -z "$FILE_PATH" ]; then
	printf '%s\n' 'Provide a filename to lookup. See "--help".' 1>&2
	exit 1
fi

GIT_FILE_HISTORY='git-file-history'
if ! which $GIT_FILE_HISTORY &>/dev/null; then
	printf '%s\n' "'$GIT_FILE_HISTORY' is a required dependency. See '--help'." 1>&2
	exit 1
fi

SUMMARY=''
logger "Nuking $FILE_PATH : Start"
delete_commits                               \
	&& [ ! "$DRY_RUN" ]                        \
	&& [ "$REMOVE_ORIGINAL" ] && delete_backup \
	&& [ "$EXPIRE"          ] && delete_reflog \
	&& [ "$PRUNE"           ] && delete_objects
logger "Nuking $FILE_PATH : End"
printf '%s\n' "$SUMMARY"
